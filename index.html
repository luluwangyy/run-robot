<!DOCTYPE html>
<html>
<head>
    <title>Lulu Robot Control - Enhanced</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1000px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .tab:hover {
            color: #667eea;
        }
        
        .tab.active {
            color: #667eea;
            font-weight: bold;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #667eea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .status-bar {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #4CAF50;
        }
        
        .status-dot.disconnected {
            background: #f44336;
            animation: none;
        }
        
        .status-dot.recording {
            background: #ff0000;
            animation: pulse 0.5s infinite;
        }
        
        .status-dot.manual {
            background: #ff9800;
            animation: pulse 1s infinite;
        }
        
        .status-dot.smiling {
            background: #ffeb3b;
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Home Position Section */
        .home-section {
            background: #e8f5e9;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .home-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .position-display {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .servo-positions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .servo-pos {
            background: #f5f5f5;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }
        
        .servo-pos .id {
            font-weight: bold;
            color: #667eea;
        }
        
        .servo-pos .angle {
            color: #333;
            font-size: 14px;
        }
        
        /* Recording Section */
        .recording-section {
            background: #fff3cd;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .recording-section.active {
            background: #ffebee;
        }
        
        .recording-mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 10px;
        }
        
        .mode-option {
            flex: 1;
            padding: 10px;
            text-align: center;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mode-option:hover {
            border-color: #667eea;
        }
        
        .mode-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .recording-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        
        .info-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        /* Camera Section */
        .camera-section {
            background: #f9f9f9;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto 20px;
            border-radius: 15px;
            overflow: hidden;
            background: #000;
            display: none;
        }
        
        .camera-container.active {
            display: block;
        }
        
        #webcam, #output-canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 15px;
        }
        
        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .smile-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            background: white;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .smile-indicator.active {
            background: #4CAF50;
            animation: pulse 1s infinite;
        }
        
        /* Control Sections */
        .control-section {
            margin-bottom: 30px;
        }
        
        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .start-button {
            background: #4CAF50;
        }
        
        .start-button:hover:not(:disabled) {
            background: #45a049;
        }
        
        .stop-button {
            background: #f44336;
        }
        
        .stop-button:hover:not(:disabled) {
            background: #da190b;
        }
        
        .home-button {
            background: #ff9800;
        }
        
        .home-button:hover:not(:disabled) {
            background: #f57c00;
        }
        
        .record-button {
            background: #e91e63;
        }
        
        .record-button:hover:not(:disabled) {
            background: #c2185b;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .speed-control label {
            font-weight: 600;
            color: #333;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="text"], input[type="number"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            flex: 1;
        }
        
        input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .speed-value {
            background: #f5f5f5;
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 60px;
            text-align: center;
            font-weight: 600;
        }
        
        .pattern-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .pattern-button {
            flex: 1;
            min-width: 100px;
        }
        
        .pattern-button.active {
            background: #4CAF50;
        }
        
        .sequence-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .sequence-item {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .sequence-item:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }
        
        .log-area {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        
        .robot-status {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 10px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
        }
        
        .status-label {
            font-weight: 600;
            color: #666;
        }
        
        .status-value {
            color: #333;
        }
        
        .instructions {
            background: #e3f2fd;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }
        
        .instructions h4 {
            margin-bottom: 10px;
            color: #1976d2;
        }
        
        .instructions ul {
            margin-left: 20px;
            color: #555;
        }
        
        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Lulu Robot Control</h1>
        
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot disconnected" id="status-dot"></div>
                <span id="status-text">Disconnected</span>
            </div>
            <div>
                <span id="mqtt-status">MQTT: Offline</span>
            </div>
            <div class="status-indicator">
                <div class="status-dot disconnected" id="camera-status-dot"></div>
                <span id="camera-status-text">Camera: Off</span>
            </div>
            <div class="status-indicator" id="manual-indicator" style="display: none;">
                <div class="status-dot manual"></div>
                <span>Manual Mode</span>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('control')">üéÆ Control</button>
            <button class="tab" onclick="switchTab('home')">üè† Home Position</button>
            <button class="tab" onclick="switchTab('recording')">üé¨ Recording</button>
            <button class="tab" onclick="switchTab('smile')">üòä Smile Detection</button>
        </div>

        <!-- Control Tab -->
        <div class="tab-content active" id="control-tab">
            <div class="control-section">
                <h3>üéÆ Main Controls</h3>
                <div class="button-grid">
                    <button class="start-button" onclick="sendCommand('start')">‚ñ∂ START</button>
                    <button class="stop-button" onclick="sendCommand('smooth_stop')">‚èπ SMOOTH STOP</button>
                    <button onclick="sendCommand('reset')">üîÑ RESET</button>
                    <button onclick="sendCommand('status')">üìä STATUS</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>üé≠ Movement Patterns</h3>
                <div class="pattern-buttons">
                    <button class="pattern-button" onclick="setPattern('wave')" id="wave-btn">üëã Wave</button>
                    <button class="pattern-button" onclick="setPattern('dance')" id="dance-btn">üíÉ Dance</button>
                    <button class="pattern-button" onclick="setPattern('happy')" id="happy-btn">üòÑ Happy</button>
                    <button class="pattern-button" onclick="setPattern('nod')" id="nod-btn">üôÜ Nod</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>‚ö° Speed Control</h3>
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speed-slider" min="10" max="200" value="50" 
                           oninput="updateSpeed(this.value)">
                    <div class="speed-value" id="speed-value">0.05s</div>
                </div>
            </div>
            
            <div class="robot-status">
                <div class="status-item">
                    <span class="status-label">Robot State:</span>
                    <span class="status-value" id="robot-state">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Current Pattern:</span>
                    <span class="status-value" id="current-pattern">None</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Speed:</span>
                    <span class="status-value" id="current-speed">0.05</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Commands Sent:</span>
                    <span class="status-value" id="cmd-count">0</span>
                </div>
            </div>
        </div>

        <!-- Home Position Tab -->
        <div class="tab-content" id="home-tab">
            <div class="home-section">
                <h3>üè† Home Position Setup</h3>
                
                <div class="instructions">
                    <h4>üìù Instructions:</h4>
                    <ul>
                        <li>Click "Start Manual Mode" to disable servo torque</li>
                        <li>Physically move the robot to your desired home position</li>
                        <li>Click "Capture Position" to save as new home</li>
                        <li>Use "Reset to Default" to restore factory settings</li>
                    </ul>
                </div>
                
                <div class="home-controls">
                    <button class="home-button" onclick="startManualPositioning()" id="manual-mode-btn">
                        üîß Start Manual Mode
                    </button>
                    <button onclick="captureHomePosition()" id="capture-home-btn" disabled>
                        üì∏ Capture Position
                    </button>
                    <button onclick="resetHomePosition()">
                        üîÑ Reset to Default
                    </button>
                    <button onclick="testHomePosition()">
                        üèÉ Go to Home
                    </button>
                </div>
                
                <div class="position-display" id="position-display">
                    <h4>Current Home Positions:</h4>
                    <div class="servo-positions" id="home-positions">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Recording Tab -->
        <div class="tab-content" id="recording-tab">
            <div class="recording-section" id="recording-section">
                <h3>üé¨ Sequence Recording</h3>
                
                <div class="recording-mode-selector">
                    <div class="mode-option selected" onclick="selectRecordingMode('manual')" id="manual-mode">
                        <strong>üì∑ Manual</strong><br>
                        <small>Frame-by-frame capture</small>
                    </div>
                    <div class="mode-option" onclick="selectRecordingMode('continuous')" id="continuous-mode">
                        <strong>üé• Continuous</strong><br>
                        <small>Automatic motion capture</small>
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <input type="text" id="sequence-name" placeholder="Enter sequence name (e.g., 'dance')">
                    <div style="margin-top: 10px;">
                        <label>Sample Rate (continuous mode):</label>
                        <input type="number" id="sample-rate" value="10" min="1" max="30" style="width: 80px;">
                        <span>frames/sec</span>
                    </div>
                </div>
                
                <div class="button-grid">
                    <button class="record-button" onclick="startRecording()" id="start-rec-btn">
                        üî¥ Start Recording
                    </button>
                    <button onclick="recordFrame()" id="record-frame-btn" disabled>
                        üì∏ Capture Frame
                    </button>
                    <button class="stop-button" onclick="stopRecording()" id="stop-rec-btn" disabled>
                        ‚èπ Stop & Save
                    </button>
                </div>
                
                <div class="recording-info" id="recording-info" style="display: none;">
                    <div class="info-item">
                        <div class="info-label">Mode</div>
                        <div class="info-value" id="rec-mode">Manual</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Frames</div>
                        <div class="info-value" id="frame-count">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Duration</div>
                        <div class="info-value" id="rec-duration">0s</div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <strong>Saved Sequences:</strong>
                        <button onclick="listSequences()" style="padding: 5px 15px;">
                            üîÑ Refresh
                        </button>
                    </div>
                    <div class="sequence-list" id="sequence-list">
                        <span style="color: #999; font-size: 12px;">No sequences loaded</span>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <label>Playback Speed:</label>
                    <input type="range" id="playback-speed" min="0.1" max="2" value="1" step="0.1"
                           oninput="document.getElementById('playback-speed-value').textContent = this.value + 'x'">
                    <span id="playback-speed-value">1x</span>
                </div>
            </div>
        </div>

        <!-- Smile Detection Tab -->
        <div class="tab-content" id="smile-tab">
            <div class="camera-section">
                <h3>üòä Smile Detection Control</h3>
                
                <div class="camera-container" id="camera-container">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="output-canvas"></canvas>
                    <div class="smile-indicator" id="smile-indicator">üòê</div>
                </div>
                
                <div class="button-grid">
                    <button onclick="toggleCamera()" id="camera-btn">üì∏ Start Camera</button>
                    <button onclick="calibrateSmile()">üéØ Calibrate</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <label>
                        <input type="checkbox" id="smile-enable" onchange="toggleSmileDetection()">
                        Enable smile trigger
                    </label>
                </div>
                
                <div style="margin: 15px 0;">
                    <label>Threshold: <span id="threshold-value">60%</span></label>
                    <input type="range" id="smile-threshold" min="10" max="90" value="60" 
                           oninput="updateSmileThreshold(this.value)">
                </div>
                
                <div style="margin: 15px 0;">
                    <label>Trigger Pattern:</label>
                    <select id="smile-pattern" style="padding: 8px; border-radius: 5px; border: 2px solid #ddd;">
                        <option value="wave">Wave</option>
                        <option value="dance">Dance</option>
                        <option value="happy">Happy</option>
                        <option value="nod">Nod</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="log-area" id="log">
            System ready. Click connect to start...
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button id="connect-btn" onclick="connectMQTT()">üîå Connect</button>
        </div>
    </div>

    <script>
        // MQTT Configuration
        const BROKER = "0640aec6af724530bf88d7d8f3a6b10d.s1.eu.hivemq.cloud";
        const PORT = 8884;
        const USERNAME = "lulu-pi";
        const PASSWORD = "Wang20198112@";
        const COMMAND_TOPIC = "lulu/hand/cmd";
        const STATUS_TOPIC = "lulu/hand/status";
        
        // Global variables
        let client = null;
        let connected = false;
        let currentPattern = "wave";
        let commandCount = 0;
        let isRecording = false;
        let recordingMode = 'manual';
        let recordedFrames = 0;
        let recordingStartTime = null;
        let currentSequenceName = "";
        let isManualMode = false;
        let homePositions = {};
        
        // Camera variables
        let camera = null;
        let faceMesh = null;
        let cameraActive = false;
        let smileDetectionEnabled = false;
        let smileThreshold = 60;
        let lastTriggerTime = 0;
        let calibrationMode = false;
        let maxSmileScore = 0;

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        // Home position functions
        function startManualPositioning() {
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            sendCommand('set_home_position');
            isManualMode = true;
            
            document.getElementById('manual-mode-btn').disabled = true;
            document.getElementById('capture-home-btn').disabled = false;
            document.getElementById('manual-indicator').style.display = 'flex';
            
            log('üîß Manual positioning mode activated');
            log('Move robot to desired home position...');
        }

        function captureHomePosition() {
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            sendCommand('capture_home');
            isManualMode = false;
            
            document.getElementById('manual-mode-btn').disabled = false;
            document.getElementById('capture-home-btn').disabled = true;
            document.getElementById('manual-indicator').style.display = 'none';
            
            log('üì∏ Capturing home position...');
        }

        function resetHomePosition() {
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            if (confirm('Reset to default home position?')) {
                sendCommand('reset_home');
                log('üîÑ Resetting to default home position');
            }
        }

        function testHomePosition() {
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            sendCommand('reset');
            log('üèÉ Moving to home position');
        }

        function updateHomePositionDisplay(positions) {
            const container = document.getElementById('home-positions');
            container.innerHTML = '';
            
            for (const [id, angle] of Object.entries(positions)) {
                const div = document.createElement('div');
                div.className = 'servo-pos';
                div.innerHTML = `
                    <div class="id">Servo ${id}</div>
                    <div class="angle">${parseFloat(angle).toFixed(1)}¬∞</div>
                `;
                container.appendChild(div);
            }
            
            homePositions = positions;
        }

        // Recording functions
        function selectRecordingMode(mode) {
            recordingMode = mode;
            document.querySelectorAll('.mode-option').forEach(opt => opt.classList.remove('selected'));
            document.getElementById(`${mode}-mode`).classList.add('selected');
            
            // Show/hide frame button based on mode
            if (mode === 'continuous') {
                document.getElementById('record-frame-btn').style.display = 'none';
            } else {
                document.getElementById('record-frame-btn').style.display = 'block';
            }
        }

        function startRecording() {
            const seqName = document.getElementById('sequence-name').value.trim();
            
            if (!seqName) {
                alert('Please enter a sequence name!');
                return;
            }
            
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            const sampleRate = parseInt(document.getElementById('sample-rate').value);
            
            sendCommand('start_recording', { 
                name: seqName, 
                mode: recordingMode,
                sample_rate: sampleRate 
            });
            
            isRecording = true;
            recordedFrames = 0;
            recordingStartTime = Date.now();
            currentSequenceName = seqName;
            
            // Update UI
            document.getElementById('start-rec-btn').disabled = true;
            document.getElementById('stop-rec-btn').disabled = false;
            document.getElementById('recording-section').classList.add('active');
            document.getElementById('recording-info').style.display = 'grid';
            document.getElementById('rec-mode').textContent = recordingMode === 'continuous' ? 'Continuous' : 'Manual';
            document.getElementById('frame-count').textContent = '0';
            
            if (recordingMode === 'manual') {
                document.getElementById('record-frame-btn').disabled = false;
                log(`üì∑ Manual recording started: ${seqName}`);
                log('Position robot and click "Capture Frame"');
            } else {
                document.getElementById('record-frame-btn').disabled = true;
                log(`üé• Continuous recording started: ${seqName}`);
                log('Move robot smoothly - recording automatically');
            }
            
            // Start duration counter
            updateRecordingDuration();
        }

        function updateRecordingDuration() {
            if (isRecording && recordingStartTime) {
                const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
                document.getElementById('rec-duration').textContent = `${duration}s`;
                setTimeout(updateRecordingDuration, 1000);
            }
        }

        function recordFrame() {
            if (!isRecording || recordingMode !== 'manual' || !connected) {
                return;
            }
            
            sendCommand('record_frame');
            recordedFrames++;
            document.getElementById('frame-count').textContent = recordedFrames;
            
            log(`üì∏ Frame ${recordedFrames} captured`);
        }

        function stopRecording() {
            if (!isRecording || !connected) {
                return;
            }
            
            sendCommand('stop_recording');
            
            isRecording = false;
            recordingStartTime = null;
            
            // Update UI
            document.getElementById('start-rec-btn').disabled = false;
            document.getElementById('record-frame-btn').disabled = true;
            document.getElementById('stop-rec-btn').disabled = true;
            document.getElementById('recording-section').classList.remove('active');
            document.getElementById('recording-info').style.display = 'none';
            
            log(`‚èπ Recording stopped`);
        }

        function listSequences() {
            if (!connected) {
                return;
            }
            sendCommand('list_sequences');
        }

        function displaySequences(sequences) {
            const listDiv = document.getElementById('sequence-list');
            
            if (!sequences || sequences.length === 0) {
                listDiv.innerHTML = '<span style="color: #999; font-size: 12px;">No sequences saved yet</span>';
                return;
            }
            
            listDiv.innerHTML = '';
            sequences.forEach(seq => {
                const item = document.createElement('div');
                item.className = 'sequence-item';
                item.textContent = seq;
                item.onclick = () => playSequence(seq);
                listDiv.appendChild(item);
            });
            
            log(`üìã Loaded ${sequences.length} sequences`);
        }

        function playSequence(seqName) {
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            const speed = parseFloat(document.getElementById('playback-speed').value);
            sendCommand('play_sequence', { name: seqName, speed: speed });
            log(`‚ñ∂ Playing sequence: ${seqName} (${speed}x speed)`);
        }

        // Camera and smile detection
        function initializeFaceMesh() {
            if (!faceMesh) {
                faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults(onFaceResults);
            }
        }

        function calculateSmileScore(landmarks) {
            if (!landmarks || landmarks.length === 0) return 0;

            const leftMouthCorner = landmarks[61];
            const rightMouthCorner = landmarks[291];
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            
            const mouthWidth = Math.sqrt(
                Math.pow(rightMouthCorner.x - leftMouthCorner.x, 2) +
                Math.pow(rightMouthCorner.y - leftMouthCorner.y, 2)
            );
            
            const mouthHeight = Math.sqrt(
                Math.pow(upperLip.x - lowerLip.x, 2) +
                Math.pow(upperLip.y - lowerLip.y, 2)
            );
            
            const aspectRatio = mouthWidth / (mouthHeight + 0.001);
            const avgMouthCornerY = (leftMouthCorner.y + rightMouthCorner.y) / 2;
            const lipCenterY = (upperLip.y + lowerLip.y) / 2;
            const cornerLift = lipCenterY - avgMouthCornerY;
            
            let smileScore = 0;
            
            if (aspectRatio > 3.0) {
                smileScore += Math.min(50, (aspectRatio - 3.0) * 25);
            }
            
            if (cornerLift > 0) {
                smileScore += Math.min(50, cornerLift * 500);
            }
            
            return Math.min(100, Math.max(0, smileScore));
        }

        function onFaceResults(results) {
            const canvas = document.getElementById('output-canvas');
            const ctx = canvas.getContext('2d');
            const video = document.getElementById('webcam');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                const smileScore = calculateSmileScore(landmarks);
                updateSmileUI(smileScore);
                
                if (calibrationMode) {
                    maxSmileScore = Math.max(maxSmileScore, smileScore);
                }
                
                if (smileDetectionEnabled && smileScore > smileThreshold && connected) {
                    const now = Date.now();
                    if (now - lastTriggerTime > 3000) {
                        triggerSmileAction(smileScore);
                        lastTriggerTime = now;
                    }
                }
            }
        }

        function updateSmileUI(smileScore) {
            const indicator = document.getElementById('smile-indicator');
            
            if (smileScore > smileThreshold) {
                indicator.textContent = 'üòÑ';
                indicator.classList.add('active');
            } else if (smileScore > 30) {
                indicator.textContent = 'üôÇ';
                indicator.classList.remove('active');
            } else {
                indicator.textContent = 'üòê';
                indicator.classList.remove('active');
            }
        }

        async function toggleCamera() {
            if (!cameraActive) {
                try {
                    const video = document.getElementById('webcam');
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 640, height: 480 } 
                    });
                    video.srcObject = stream;
                    
                    if (!faceMesh) {
                        initializeFaceMesh();
                    }
                    
                    camera = new Camera(video, {
                        onFrame: async () => {
                            if (cameraActive && faceMesh) {
                                await faceMesh.send({ image: video });
                            }
                        },
                        width: 640,
                        height: 480
                    });
                    
                    camera.start();
                    cameraActive = true;
                    
                    document.getElementById('camera-container').classList.add('active');
                    document.getElementById('camera-btn').textContent = '‚èπ Stop Camera';
                    document.getElementById('camera-status-dot').classList.add('connected');
                    document.getElementById('camera-status-text').textContent = 'Camera: On';
                    
                    log('üì∏ Camera started');
                } catch (error) {
                    log(`Camera error: ${error.message}`);
                }
            } else {
                stopCamera();
            }
        }

        function stopCamera() {
            if (camera) {
                camera.stop();
                camera = null;
            }
            
            cameraActive = false;
            
            const video = document.getElementById('webcam');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            document.getElementById('camera-container').classList.remove('active');
            document.getElementById('camera-btn').textContent = 'üì∏ Start Camera';
            document.getElementById('camera-status-dot').classList.remove('connected');
            document.getElementById('camera-status-text').textContent = 'Camera: Off';
            
            log('üì∏ Camera stopped');
        }

        function toggleSmileDetection() {
            smileDetectionEnabled = document.getElementById('smile-enable').checked;
            log(smileDetectionEnabled ? 'üòä Smile detection enabled' : 'üòä Smile detection disabled');
            
            if (smileDetectionEnabled && !cameraActive) {
                toggleCamera();
            }
        }

        function updateSmileThreshold(value) {
            smileThreshold = parseInt(value);
            document.getElementById('threshold-value').textContent = `${smileThreshold}%`;
        }

        function calibrateSmile() {
            if (!cameraActive) {
                log('‚ùå Please start camera first');
                return;
            }
            
            calibrationMode = true;
            maxSmileScore = 0;
            log('üéØ Calibration started. Smile wide for 3 seconds...');
            
            setTimeout(() => {
                calibrationMode = false;
                if (maxSmileScore > 0) {
                    const newThreshold = Math.round(maxSmileScore * 0.7);
                    document.getElementById('smile-threshold').value = newThreshold;
                    updateSmileThreshold(newThreshold);
                    log(`‚úÖ Calibration complete. Threshold set to ${newThreshold}%`);
                }
            }, 3000);
        }

        function triggerSmileAction(smileScore) {
            const pattern = document.getElementById('smile-pattern').value;
            
            sendCommand('smile_trigger', {
                pattern: pattern,
                smile_score: smileScore
            });
            
            log(`üòÑ Smile triggered: ${pattern} (${Math.round(smileScore)}%)`);
        }

        // MQTT functions
        function log(message) {
            const logArea = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `[${timestamp}] ${message}<br>`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function updateStatus(status, text) {
            document.getElementById('status-dot').className = 'status-dot ' + status;
            document.getElementById('status-text').textContent = text;
        }

        function connectMQTT() {
            const brokerUrl = `wss://${BROKER}:${PORT}/mqtt`;
            
            const options = {
                clean: true,
                connectTimeout: 4000,
                clientId: 'robot_controller_' + Math.random().toString(16).substr(2, 8),
                username: USERNAME,
                password: PASSWORD,
                reconnectPeriod: 1000,
            };

            log('Connecting to MQTT broker...');
            updateStatus('connecting', 'Connecting...');
            
            client = mqtt.connect(brokerUrl, options);
            
            client.on('connect', function () {
                connected = true;
                log('Connected to MQTT broker');
                updateStatus('connected', 'Connected');
                document.getElementById('mqtt-status').textContent = 'MQTT: Online';
                document.getElementById('connect-btn').style.display = 'none';
                
                client.subscribe(STATUS_TOPIC, function (err) {
                    if (!err) {
                        log('Subscribed to status updates');
                        listSequences();
                    }
                });
            });

            client.on('message', function (topic, message) {
                try {
                    const data = JSON.parse(message.toString());
                    
                    if (data.status) {
                        document.getElementById('robot-state').textContent = data.status;
                        
                        if (data.status === 'manual_positioning') {
                            log('‚ö†Ô∏è Torque disabled - position robot manually');
                        } else if (data.status === 'home_captured') {
                            log('‚úÖ Home position captured');
                            if (data.positions) {
                                updateHomePositionDisplay(data.positions);
                            }
                        } else if (data.status === 'home_reset') {
                            log('‚úÖ Home position reset to defaults');
                        } else if (data.status === 'recording_manual' || data.status === 'recording_continuous') {
                            if (data.frame_count !== undefined) {
                                document.getElementById('frame-count').textContent = data.frame_count;
                            }
                        } else if (data.status === 'frame_recorded') {
                            document.getElementById('frame-count').textContent = data.frame_count;
                        } else if (data.status === 'saved') {
                            log(`‚úÖ Saved: ${data.sequence_name} (${data.frame_count} frames)`);
                            setTimeout(listSequences, 500);
                        } else if (data.status === 'sequences_list') {
                            displaySequences(data.sequences);
                        } else if (data.status === 'detailed') {
                            if (data.home_positions) {
                                updateHomePositionDisplay(data.home_positions);
                            }
                        }
                    }
                    
                    if (data.pattern) {
                        document.getElementById('current-pattern').textContent = data.pattern;
                    }
                    if (data.speed !== undefined) {
                        document.getElementById('current-speed').textContent = data.speed;
                    }
                    
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            });

            client.on('error', function(err) {
                log('Connection error: ' + err.message);
                updateStatus('disconnected', 'Error');
                connected = false;
            });

            client.on('close', function() {
                updateStatus('disconnected', 'Disconnected');
                document.getElementById('mqtt-status').textContent = 'MQTT: Offline';
                connected = false;
            });
        }

        function sendCommand(command, extraData = {}) {
            if (!connected) {
                log('‚ùå Not connected to MQTT');
                return;
            }
            
            let message = {
                command: command,
                timestamp: Date.now(),
                ...extraData
            };
            
            if (command === 'start') {
                message.pattern = currentPattern;
            }
            
            client.publish(COMMAND_TOPIC, JSON.stringify(message));
            commandCount++;
            document.getElementById('cmd-count').textContent = commandCount;
            log(`üì§ Sent: ${command}`);
        }

        function setPattern(pattern) {
            currentPattern = pattern;
            
            document.querySelectorAll('.pattern-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(pattern + '-btn').classList.add('active');
            
            log(`Pattern set to: ${pattern}`);
        }

        function updateSpeed(value) {
            const speed = value / 1000;
            document.getElementById('speed-value').textContent = speed.toFixed(3) + 's';
            
            if (connected) {
                sendCommand('speed', { value: speed });
                log(`‚ö° Speed: ${speed}s`);
            }
        }

        // Auto-connect on page load
        window.addEventListener('load', function() {
            setTimeout(connectMQTT, 500);
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (camera) {
                stopCamera();
            }
        });
    </script>
</body>
</html>
